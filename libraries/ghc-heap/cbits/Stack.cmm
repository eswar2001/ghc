#include "Cmm.h"

#if SIZEOF_VOID_P == 4
#define HALF_WORD_ bits16
#elif SIZEOF_VOID_P == 8
#define HALF_WORD_ bits32
#else
#error Unknown word size
#endif

// TODO: comment out
// Uncomment to enable assertions during development
#define DEBUG 1

advanceStackFrameIterzh (P_ stack, W_ index) {
  P_ newStack;
  W_ newIndex;
  W_ hasNext;

  W_ frameSize;
  (frameSize) = ccall stackFrameSize(stack, index);

  P_ nextClosurePtr;
  nextClosurePtr = (StgStack_sp(stack) + WDS(index) + WDS(frameSize));

  P_ stackBottom, stackArrayPtr;
  stackArrayPtr = stack + SIZEOF_StgHeader + OFFSET_StgStack_stack;
  HALF_WORD_ stackSize;
  W_ stackSizeInBytes;
  stackSize = StgStack_stack_size(stack);
  stackSizeInBytes = WDS(TO_W_(stackSize));
  stackBottom = stackSizeInBytes + stackArrayPtr;

  if(nextClosurePtr < stackBottom) (likely: True) {
    // ccall debugBelch("advanceStackFrameIterzh - ordinary frame \n");
    newStack = stack;
    newIndex = index + frameSize;
    hasNext = 1;
  } else {
    P_ underflowFrameStack;
    (underflowFrameStack) = ccall getUnderflowFrameStack(stack, index);
    if (underflowFrameStack == NULL) (likely: True) {
      // ccall debugBelch("advanceStackFrameIterzh - last frame \n");
      newStack = NULL;
      newIndex = NULL;
      hasNext = NULL;
    } else {
      // ccall debugBelch("advanceStackFrameIterzh - underflow frame \n");
      newStack = underflowFrameStack;
      newIndex = NULL;
      hasNext = 1;
    }
  }

  // TODO: Execute this block only in -DDEBUG
#if DEBUG
  if(hasNext > 0) {
    P_ nextClosure;
    nextClosure = StgStack_sp(stack) + WDS(index);
    ASSERT(LOOKS_LIKE_CLOSURE_PTR(nextClosure));
//    ccall checkSTACK(stack);
  }
#endif

  // ccall debugBelch("advanceStackFrameIterzh - stack %p,  newStack %p, frameSize %ul, newIdex %ul, hasNext %ul, stackBottom %p\n", stack, newStack, frameSize, newIndex, hasNext, stackBottom);
  return (newStack, newIndex, hasNext);
}

derefStackWordzh (P_ stack, W_ index) {
  P_ sp;
  sp = StgStack_sp(stack);

  return (W_[sp + WDS(index)]);
}

getInfoTableTypezh (P_ stack, W_ index) {
    P_ p, info;
    p = StgStack_sp(stack) + WDS(index);
    ASSERT(LOOKS_LIKE_CLOSURE_PTR(p));
    info  = %INFO_PTR(p);

    W_ type;
    type = TO_W_(%INFO_TYPE(%STD_INFO(info)));
    // ccall debugBelch("getInfoTableTypezh - stack %p , index %ul, closure ptr p %p, info ptr %p, itbl type %ul\n", stack, index, p, info, type);
    return (type);
}

getSmallBitmapzh(P_ stack, W_ index) {
  P_ c;
  c = StgStack_sp(stack) + WDS(index);
  ASSERT(LOOKS_LIKE_CLOSURE_PTR(c));

  W_ bitmap, size, specialType;
  (bitmap) = ccall getBitmapWord(c);
  (size) = ccall getBitmapSize(c);

  return (bitmap, size);
}

getRetSmallSpecialTypezh(P_ stack, W_ index) {
  P_ c;
  c = StgStack_sp(stack) + WDS(index);
  ASSERT(LOOKS_LIKE_CLOSURE_PTR(c));

  W_ specialType;
  (specialType) = ccall getSpecialRetSmall(c);

  return (specialType);
}

getRetFunSmallBitmapzh(P_ stack, W_ index) {
  P_ c;
  c = StgStack_sp(stack) + WDS(index);
  ASSERT(LOOKS_LIKE_CLOSURE_PTR(c));

  W_ bitmap, size, specialType;
  (bitmap) = ccall getRetFunBitmapWord(c);
  (size) = ccall getRetFunBitmapSize(c);

  return (bitmap, size);
}

getLargeBitmapzh(P_ stack, W_ index){
  P_ c, stgArrBytes;
  W_ size;
  c = StgStack_sp(stack) + WDS(index);
  ASSERT(LOOKS_LIKE_CLOSURE_PTR(c));

  (stgArrBytes) = ccall getLargeBitmaps(MyCapability(), c);
  (size) = ccall getLargeBitmapSize(c);

  return (stgArrBytes, size);
}

getBCOLargeBitmapzh(P_ stack, W_ index){
  P_ c, stgArrBytes;
  W_ size;
  c = StgStack_sp(stack) + WDS(index);
  ASSERT(LOOKS_LIKE_CLOSURE_PTR(c));

  (stgArrBytes) = ccall getBCOLargeBitmaps(MyCapability(), c);
  (size) = ccall getBCOLargeBitmapSize(c);

  return (stgArrBytes, size);
}

getRetFunLargeBitmapzh(P_ stack, W_ index){
  P_ c, stgArrBytes;
  W_ size;
  c = StgStack_sp(stack) + WDS(index);
  ASSERT(LOOKS_LIKE_CLOSURE_PTR(c));

  (stgArrBytes) = ccall getRetFunLargeBitmaps(MyCapability(), c);
  (size) = ccall getRetFunSize(c);

  return (stgArrBytes, size);
}

// TODO: Use generalized version unpackClosureReferencedByFramezh with offset=0
unpackClosureFromStackFramezh(P_ stack, W_ index){
  P_ closurePtr, closurePtrPrime;
  // TODO: Rename closurePtr -> closurePtrAddr
  closurePtr = (StgStack_sp(stack) + WDS(index));
  closurePtrPrime = P_[closurePtr];
  ASSERT(LOOKS_LIKE_CLOSURE_PTR(closurePtrPrime));
  jump stg_unpackClosurezh(closurePtrPrime);
}

getUpdateFrameTypezh(P_ stack, W_ index){
  P_ c;
  c = StgStack_sp(stack) + WDS(index);
  ASSERT(LOOKS_LIKE_CLOSURE_PTR(c));

  W_ type;
  (type) = ccall getUpdateFrameType(c);
  return (type);
}

unpackClosureReferencedByFramezh(W_ offset, P_ stack, W_ index){
  P_ closurePtr, closurePtrPrime;
  // TODO: Rename closurePtr -> closurePtrAddr
  closurePtr = (StgStack_sp(stack) + WDS(index) + offset);
  closurePtrPrime = P_[closurePtr];
  ASSERT(LOOKS_LIKE_CLOSURE_PTR(closurePtrPrime));
  jump stg_unpackClosurezh(closurePtrPrime);
}

getCatchFrameExceptionsBlockedzh(P_ stack, W_ index){
  P_ closurePtr;
  closurePtr = (StgStack_sp(stack) + WDS(index));
  ASSERT(LOOKS_LIKE_CLOSURE_PTR(closurePtr));

  W_ exceptions_blocked;
  exceptions_blocked = StgCatchFrame_exceptions_blocked(closurePtr);
  return (exceptions_blocked);
}

// TODO: Rename: index -> wordOffset, offset -> byteOffset
getWordzh(P_ stack, W_ index, W_ offset){
  P_ wordAddr;
  wordAddr = (StgStack_sp(stack) + WDS(index) + offset);
  return (W_[wordAddr]);
}

// TODO: Rename: index -> wordOffset, offset -> byteOffset
getHalfWordzh(P_ stack, W_ index, W_ offset){
  P_ wordAddr;
  wordAddr = (StgStack_sp(stack) + WDS(index) + offset);
  bits32 result;
  result = bits32[wordAddr];
  return (result);
}

getUnderflowFrameNextChunkzh(P_ stack, W_ index){
  P_ closurePtr, closurePtrPrime, updateePtr;
  closurePtr = (StgStack_sp(stack) + WDS(index));
  ASSERT(LOOKS_LIKE_CLOURE_PTR(closurePtr));

  P_ next_chunk;
  (next_chunk) = ccall getUnderflowFrameNextChunk(closurePtr);
  ASSERT(LOOKS_LIKE_CLOURE_PTR(next_chunk));
  return (next_chunk);
}

getRetFunTypezh(P_ stack, W_ index){
  P_ c;
  c = StgStack_sp(stack) + WDS(index);
  ASSERT(LOOKS_LIKE_CLOSURE_PTR(c));

  W_ type;
  (type) = ccall getRetFunType(c);
  return (type);
}
