#!/usr/bin/env python
# -*- coding: utf-8 -*-

# This script generates the primop descriptions for many similar ByteArray#
# and Addr# access operations.  Its output is #include-d into primops.txt.pp.

from typing import Optional, NamedTuple
import textwrap
import argparse

arg_parser = argparse.ArgumentParser()
arg_parser.add_argument('addr_or_bytearray',
                        choices = ["addr-access-ops", "bytearray-access-ops"],
                        )
arg_parser.add_argument('output_file',
                        type=argparse.FileType('w'),
                        metavar='FILE',
                        )
args = arg_parser.parse_args()
write = args.output_file.write



write('''
-- Do not edit.
-- This file is generated by compiler/GHC/Builtin/gen_bytearray_addr_access_ops.py.
-- (The build system should take care of this for you.)

''')

class ElementType(NamedTuple):
    name: str
    rep_ty: str
    desc: str
    width: Optional[int]

MACH_WORD = None

element_types = [
    # (name, representation type, human description, width)
    #
    # width in bytes.
    # width == None denotes machine word

    ElementType("Char",      "Char#",        "8-bit character",                       1),
    ElementType("WideChar",  "Char#",        "32-bit character",                      4),
    ElementType("Int",       "Int#",         "word-sized integer",                    MACH_WORD),
    ElementType("Word",      "Word#",        "word-sized unsigned integer",           MACH_WORD),
    ElementType("Addr",      "Addr#",        "machine address",                       MACH_WORD),
    ElementType("Float",     "Float#",       "single-precision floating-point value", 4),
    ElementType("Double",    "Double#",      "double-precision floating-point value", 8),
    ElementType("StablePtr", "StablePtr# a", "'StablePtr#' value",                    MACH_WORD),
]

for n in [8,16,32,64]:
    element_types += [
        ElementType(f"Int{n}",  f"Int{n}#",
                    f"{n}-bit signed integer",   n // 8),
        ElementType(f"Word{n}", f"Word{n}#",
                    f"{n}-bit unsigned integer", n // 8)
    ]

def pretty_offset(n: Optional[int]) -> str:
    if n == MACH_WORD:
        return 'machine words'
    elif n == 1:
        return 'bytes'
    else:
        return f'{n}-byte words'

def get_align_warn(n: ElementType) -> str:
    if n.width == 1:
        return ''
    return '''
        On some platforms, the access may fail
        for an insufficiently aligned @Addr#@.
    '''

def print_block(template: str, **kwargs) -> None:
    write(textwrap.dedent(template.format(**kwargs)).lstrip())
    write('\n')

def header(s: str):
    write('\n')
    print_block('''
        ------------------------------------
        -- {s}
        ------------------------------------
    ''', s=s)

if args.addr_or_bytearray == "bytearray-access-ops":
    header("ByteArray# operations")

    header('aligned index operations')
    for t in element_types:
        offset = pretty_offset(t.width)
        print_block('''
        primop IndexByteArrayOp_{name} "index{name}Array#" GenPrimOp
           ByteArray# -> Int# -> {rep_ty}
           {{Read a {desc}; offset in {offset}.}}
           with can_fail = True
        ''', offset = offset, **t._asdict())

    header('unaligned index operations')
    for t in element_types:
        if t.name in ['Int8', 'Word8']: continue
        print_block('''
        primop IndexByteArrayOp_Word8As{name} "indexWord8ArrayAs{name}#" GenPrimOp
           ByteArray# -> Int# -> {rep_ty}
           {{Read a {desc}; offset in bytes.}}
           with can_fail = True
        ''', **t._asdict())

    header('aligned read operations')
    for t in element_types:
        offset = pretty_offset(t.width)
        print_block('''
        primop ReadByteArrayOp_{name} "read{name}Array#" GenPrimOp
           MutableByteArray# s -> Int# -> State# s -> (# State# s, {rep_ty} #)
           {{Read a {desc}; offset in {offset}.}}
           with has_side_effects = True
                can_fail = True
        ''', offset = offset, **t._asdict())

    header('unaligned read operations')
    for t in element_types:
        if t.name in ['Int8', 'Word8']: continue
        print_block('''
        primop ReadByteArrayOp_Word8As{name} "readWord8ArrayAs{name}#" GenPrimOp
           MutableByteArray# s -> Int# -> State# s -> (# State# s, {rep_ty} #)
           {{Read a {desc}; offset in bytes.}}
           with has_side_effects = True
                can_fail = True
        ''', **t._asdict())

    header('aligned write operations')
    for t in element_types:
        offset = pretty_offset(t.width)
        print_block('''
        primop WriteByteArrayOp_{name} "write{name}Array#" GenPrimOp
           MutableByteArray# s -> Int# -> {rep_ty} -> State# s -> State# s
           {{Write a {desc}; offset in {offset}.}}
           with has_side_effects = True
                can_fail = True
        ''', offset = offset, **t._asdict())

    header('unaligned write operations')
    for t in element_types:
        if t.name in ['Int8', 'Word8']: continue
        print_block('''
        primop WriteByteArrayOp_Word8As{name} "writeWord8ArrayAs{name}#" GenPrimOp
           MutableByteArray# s -> Int# -> {rep_ty} -> State# s -> State# s
           {{Write a {desc}; offset in bytes.}}
           with has_side_effects = True
                can_fail = True
        ''', **t._asdict())


else: # addr_or_bytearray == "addr-access-ops":
    header("Addr# access operations")

    header('aligned index operations')
    for t in element_types:
        offset = pretty_offset(t.width)
        align_warn = get_align_warn(t)
        print_block('''
        primop IndexOffAddrOp_{name} "index{name}OffAddr#" GenPrimOp
           Addr# -> Int# -> {rep_ty}
           {{ Read a {desc}; offset in {offset}.
              {align_warn}
           }}
           with can_fail = True
        ''', offset = offset, align_warn = align_warn, **t._asdict())

    header('aligned read operations')
    for t in element_types:
        offset = pretty_offset(t.width)
        align_warn = get_align_warn(t)
        print_block('''
        primop ReadOffAddrOp_{name} "read{name}OffAddr#" GenPrimOp
           Addr# -> Int# -> State# s -> (# State# s, {rep_ty} #)
           {{ Read a {desc}; offset in {offset}.
              {align_warn}
           }}
           with has_side_effects = True
                can_fail = True
        ''', offset = offset, align_warn = align_warn, **t._asdict())

    header('aligned write operations')
    for t in element_types:
        offset = pretty_offset(t.width)
        align_warn = get_align_warn(t)
        print_block('''
        primop WriteOffAddrOp_{name} "write{name}OffAddr#" GenPrimOp
           Addr# -> Int# -> {rep_ty} -> State# s -> State# s
           {{ Write a {desc}; offset in {offset}.
              {align_warn}
           }}
           with has_side_effects = True
                can_fail = True
        ''', offset = offset, align_warn = align_warn, **t._asdict())
