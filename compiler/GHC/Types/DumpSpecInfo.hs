{-# LANGUAGE FlexibleContexts   #-}
{-# LANGUAGE FlexibleInstances  #-}
{-# LANGUAGE RecordWildCards    #-}
{-# LANGUAGE StandaloneDeriving #-}

-- | A module for the DumpSpecInfo type whose values contain information about
-- specialisations generated by GHC. Output by -ddump-specialisations flag.
module GHC.Types.DumpSpecInfo
  ( DumpSpecInfo(..)
  , DumpSpecInfoTypes(..)
  , dumpSpecialisation
  , dumpSpecialisationWithLogger
  ) where

import GHC.Core.Type
import GHC.Driver.Flags (DumpFlag(..))
import GHC.Prelude
import GHC.Types.Id
import GHC.Unit.Module
import GHC.Utils.Logger
import GHC.Utils.Outputable

import Control.Monad
import Control.Monad.IO.Class

data DumpSpecInfoTypes =
    DumpSpecInfoCustom
  | DumpSpecInfoString

data DumpSpecInfo mod id ty = DumpSpecInfo
  { -- | Module the specialisation was generated in ('Module' in GHC)
    dumpSpecInfo_module :: !mod

    -- | Was this specialisation the result of a pragma?
  , dumpSpecInfo_fromPragma :: !Bool

    -- | Overloaded function identifier ('Id' in GHC)
  , dumpSpecInfo_polyId :: !id
    -- | Overloaded function type ('Type' in GHC)
  , dumpSpecInfo_polyTy :: !ty

    -- | Specialised function identifier ('Identifier' in GHC)
  , dumpSpecInfo_specId :: !id
    -- | Specialised function type ('Type' in GHC)
  , dumpSpecInfo_specTy :: !ty

    -- | The types of the dictionaries the specialisation is for (list of 'Type'
    -- in GHC)
  , dumpSpecInfo_dicts :: ![ty]
  }

-- | This instance is intentionally written so the following composition
-- succeeds:
--
-- @read \@(DumpSpecInfo String String String) . show \@(DumpSpecInfo Module Id Type)@
instance Show (DumpSpecInfo Module Id Type) where
  show DumpSpecInfo{..} =
    renderWithContext
      defaultSDocContext
        { sdocLineLength = maxBound
        }
      $ withPprStyle (mkDumpStyle alwaysQualify)
      $ vcat
          [ text "Specialisation generated:"
          , nest 2 $ text "DumpSpecInfo" <+>
              ( braces . sep $
                  [ text "dumpSpecInfo_module" <+> equals <+> doubleQuotes (ppr dumpSpecInfo_module) <> comma
                  , text "dumpSpecInfo_fromPragma" <+> equals <+> ppr dumpSpecInfo_fromPragma <> comma
                  , text "dumpSpecInfo_polyId" <+> equals <+> doubleQuotes (ppr dumpSpecInfo_polyId) <> comma
                  , text "dumpSpecInfo_polyTy" <+> equals <+> doubleQuotes (ppr dumpSpecInfo_polyTy) <> comma
                  , text "dumpSpecInfo_specId" <+> equals <+> doubleQuotes (ppr dumpSpecInfo_specId) <> comma
                  , text "dumpSpecInfo_specTy" <+> equals <+> doubleQuotes (ppr dumpSpecInfo_specTy) <> comma
                  , text "dumpSpecInfo_dicts" <+> equals <+> ppr (map (doubleQuotes . ppr) dumpSpecInfo_dicts)
                  ]
              )
          ]

deriving instance Show (DumpSpecInfo String String String)
deriving instance Read (DumpSpecInfo String String String)
deriving instance Eq (DumpSpecInfo String String String)

dumpSpecialisation
  :: forall mod id ty m. (MonadIO m, HasLogger m, Show (DumpSpecInfo mod id ty))
  => DumpSpecInfo mod id ty
  -> m ()
dumpSpecialisation spec_info = do
    logger <- getLogger
    dumpSpecialisationWithLogger logger spec_info

dumpSpecialisationWithLogger
  :: forall mod id ty m. (MonadIO m, Show (DumpSpecInfo mod id ty))
  => Logger
  -> DumpSpecInfo mod id ty
  -> m ()
dumpSpecialisationWithLogger logger spec_info = do
    when (logHasDumpFlag logger Opt_D_dump_specialisations) $
      log_specialisation logger (text $ show spec_info)

log_specialisation :: MonadIO m => Logger -> SDoc -> m ()
log_specialisation logger doc =
    liftIO $
      putDumpFileMaybe logger
        Opt_D_dump_specialisations
            ""
            FormatText
            doc
